以下是 PDF 中**乘法优化**与**除法优化**的详细总结，包括其原理、适用场景和具体实现步骤：

---

## ✅ 一、乘法优化

### 目标：
将常数乘法转换为更高效的**移位（shift）** 和**加法（add）** 指令，因为乘法指令的执行周期通常比移位和加法长。

### 优化场景与转换规则：

| 乘法形式 | 优化后的指令 | 说明 |
|----------|---------------|------|
| \( x \times 2^n \) | `x << n` | 直接转换为左移指令 |
| \( x \times (2^n + 2^m) \) | `(x << n) + (x << m)` | 转换为两次移位后相加 |
| \( x \times (2^n - 2^m) \) | `(x << n) - (x << m)` | 转换为两次移位后相减 |

### 示例：
- \( x \times 8 \) → \( x \ll 3 \)
- \( x \times 24 \)（即 \( 16 + 8 \)） → \( (x \ll 4) + (x \ll 3) \)

### 适用场景：
- 编译时常数乘法
- 数组索引计算、地址偏移计算等

---

## ✅ 二、除法优化

### 目标：
将常数除法转换为**乘法 + 移位**操作，因为除法指令的执行开销远大于乘法和移位。

### 核心定理（Division by Invariant Integers using Multiplication）：

> 对于整数 \( n \) 和常数除数 \( d \neq 0 \)，存在非负整数 \( m, \ell \) 使得：
> \[
> \lfloor n / d \rfloor = \lfloor m \times n / 2^{N+\ell} \rfloor
> \]
> 其中 \( N \) 为整数位数（如 32 位系统中 \( N = 32 \)）。

### 优化步骤：

#### 1. **计算 \( m \) 和 \( \ell \)**
   - 枚举 \( \ell \)，寻找满足以下不等式的 \( m \)：
     \[
     2^{N+\ell} \leq m \times d \leq 2^{N+\ell} + 2^\ell
     \]
   - 对于有符号除法，\( N \) 取 \( 31 \)（即 \( N-1 \)），且 \( d \) 取绝对值。

#### 2. **转换为乘法和移位指令**
   根据 \( d \) 的值分情况处理：

| 情况 | 转换公式 | 说明 |
|------|----------|------|
| \( d = 1 \) | \( n \) | 直接返回 \( n \) |
| \( d = 2^k \) | `SRA(n + SRL(SRA(n, k-1), 32-k), k)` | 使用移位实现 |
| \( m < 2^{31} \) | `SRA(MULSH(m, n), ℓ-1) + SRL(n, 31)` | 乘高32位 + 移位 |
| 否则 | `SRA(n + MULSH(m-2^32, n), ℓ-1) + SRL(n, 31)` | 调整乘数后处理 |

### 符号说明：
- `SRA(x, n)`：算术右移
- `SRL(x, n)`：逻辑右移
- `MULSH(x, y)`：有符号乘法的高32位（对应 `mult` + `mfhi` 指令）

### 示例（伪代码）：
```c
// 原始代码
int a = n / 10;

// 优化后（假设 m=1717986919, ℓ=34）
int t = MULSH(1717986919, n);
int a = SRA(t, 2) + SRL(n, 31);
```

### 适用场景：
- 编译时常数除法
- 循环中的整数除法
- 无浮点单元的嵌入式系统

---

## ✅ 三、总结对比

| 优化类型 | 目标 | 核心方法 | 适用场景 |
|----------|------|----------|----------|
| **乘法优化** | 减少乘法指令开销 | 移位 + 加法 | 常数乘法、地址计算 |
| **除法优化** | 避免使用除法指令 | 乘法 + 移位（基于数学定理） | 常数除法、嵌入式系统 |

---

如果需要进一步解释某一部分或有具体实现问题，可以继续提问。