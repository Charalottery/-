以下是PDF中关于**死代码删除（Dead Code Elimination, DCE）** 的详细总结，包括其原理、步骤和实现方法：

---

## 📘 **DCE（死代码删除）总结**

### 一、**目标**
- 删除程序中**永远不会被执行**或**计算结果永远不会被使用**的代码，从而减少程序体积、提升执行效率。

---

### 二、**基本原则**
- **“变量是无用的，除非被证明是活跃的”**  
  - 即从程序的“活性”出发，反向标记活跃的变量和指令，未被标记的即为死代码。

---

### 三、**活跃性判断规则**
1. **直接活跃的指令**：
   - 涉及**控制流**或有**副作用**的指令引用的变量是活跃的。
   - 例如：`br`、`call`、`store`、`ret` 等指令。

2. **间接活跃的指令**：
   - 如果一条指令为**活跃变量**定值，则该指令引用的变量也是活跃的。

---

### 四、**DCE 实现步骤**

#### **步骤1：标记活跃变量与指令**
- 以函数为单位遍历所有指令。
- 从**出口指令**（如 `ret`、`br`）和**有副作用的指令**开始，反向传播活跃标记。
- 迭代更新活跃标记，直至不再变化。

#### **步骤2：删除无用指令**
- 删除所有**未被标记为活跃**的指令。
- 同时维护**定义-使用关系**，确保删除不会影响其他活跃代码。

---

### 五、**删除不可达代码**

#### **1. 删除不可达函数**
- 从 `main` 函数出发，根据**调用关系图**遍历所有可达函数。
- 未被遍历到的函数为不可达函数，可删除。

#### **2. 删除不可达基本块**
- 在控制流图（CFG）上从**入口基本块**出发进行遍历。
- 未被遍历到的基本块为不可达基本块，可删除。
- **注意**：在 `mem2reg` 等优化中可能已删除部分不可达基本块（入口块不支配不可达块）。

---

### 六、**DCE 的触发时机**
- **初次优化**：在基础优化（如常量传播、常量折叠）后进行。
- **迭代优化**：当其他优化（如条件跳转改为无条件跳转）改变 CFG 后，可再次进行 DCE。

---

### 七、**扩展：激进的死代码删除（Aggressive DCE, ADCE）**
- 适用于**循环中的变量自依赖**情况。
- 基于**控制依赖关系**而非数据流关系标记活跃性。
- 可删除传统 DCE 无法删除的无用循环或条件块。

---

### 八、**与其他优化的关系**
- **常量传播**：可能使某些条件跳转变为常量，从而产生新的不可达路径，触发新一轮 DCE。
- **循环分析**：帮助识别循环中的无用变量。
- **函数内联**：内联后可能暴露出更多死代码。

---

### 九、**示例说明**
```c
// 优化前
int x = 10;  // 未使用
int y = 20;
printf("%d", y);  // 只有 y 是活跃的

// DCE 后
int y = 20;
printf("%d", y);  // x 的定义被删除
```

---

### 十、**总结要点**
- DCE 是**基于活跃性分析**的优化。
- 适用于**函数内局部优化**和**全局不可达代码删除**。
- 可与其他优化**迭代执行**，形成优化链。
- 是实现**代码精简**和**性能提升**的基础优化之一。

---

如果还需要其它帮助，可以随时告诉我。